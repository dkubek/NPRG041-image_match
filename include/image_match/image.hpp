/**
 * @file image.hpp
 * @author DÃ¡vid Kubek
 * @date 1 March 2021
 * @brief File containing a simple image wrapper.
 *
 * This file contains a simple image wrapper for images generated by the
 * ``stb`` image loading library and simple functions for image manipulation
 * and lookup in the filesystem.
 *
 * Currently supported image types are png, jpg and bmp.
 *
 */

#ifndef _IMAGE_MATCH_IMAGE_GUARD
#define _IMAGE_MATCH_IMAGE_GUARD

#include <array>
#include <cstdint>
#include <filesystem>
#include <memory>
#include <string>

#include "gsl/gsl-lite.hpp"

namespace image_match {

/// List of recognized image extensions.
static const std::array<std::string, 4> SUPPORTED_IMAGE_EXTENSIONS{ ".png",
                                                                    ".jpeg",
                                                                    ".jpg",
                                                                    ".bmp" };

/// Helper functor destructor for image_wrapper.
struct image_wrapper_deleter
{
    void operator()(unsigned char* data) const;
};

/// Wrapper for raw data produced by the ``stb`` library.
using image_wrapper = std::unique_ptr<unsigned char, image_wrapper_deleter>;

using pixel = gsl::span<unsigned char>;

/// Simple image container.
class image
{
  public:
    /**
     * Represents a row of the image.
     */
    struct row_proxy
    {
      public:
        /**
         * Default constructor. Does not check for bounds.
         */
        row_proxy(size_t row, const image& im)
          : base_{ row * im.width() * im.channels() }
          , im_{ im }
        {}

        /**
         * Accesses a specific pixel on the row. Bound checking is not
         * performed.
         */
        pixel operator[](size_t index)
        {
            return { im_.data_.get() + base_ + index * im_.channels(),
                     im_.channels() };
        }

        /**
         * Accesses a specific pixel on the row. Bound checking is not
         * performed.
         */
        const pixel operator[](size_t index) const
        {
            return { im_.data_.get() + base_ + index * im_.channels(),
                     im_.channels() };
        }

      private:
        size_t base_;     ///< Index of the first element in the row.
        const image& im_; ///< Referenced image.
    };

    /**
     * @brief Constructs an image from given image path.
     *
     * Loads an image from the given file path. To check that the file loaded
     * successfully, use the fail() member function or the provided operator
     * bool().  If the loading fails, a message describing the problem is
     * provided by the fail_msg() member function.
     *
     * @param[in] image_path - File path of the image to load.
     */
    image(const std::filesystem::path& image_path);

    /**
     * Construct an empty image.
     *
     * Content of the newly created image is undefined.
     *
     * @param[in] width - Width of the image
     * @param[in] height - Height of the image
     * @param[in] channels - Number of channels in the image.
     */
    image(size_t width, size_t height, size_t channels);

    size_t width() const { return width_; };
    size_t height() const { return height_; };
    size_t channels() const { return channels_; };

    /**
     * @brief Returns a reference to the raw pixel data.
     *
     * The pixel data consists of height() scanlines of width() pixels, with
     * each pixel consisting of channels() interleaved 8-bit components; the
     * first pixel pointed to is top-left-most in the image. There is no
     * padding between image scanlines or between pixels, regardless of format.
     */
    image_wrapper& data() { return data_; };
    /**
     * @brief Returns a reference to the raw pixel data.
     *
     * The pixel data consists of height() scanlines of width() pixels, with
     * each pixel consisting of channels() interleaved 8-bit components; the
     * first pixel pointed to is top-left-most in the image. There is no
     * padding between image scanlines or between pixels, regardless of format.
     */
    const image_wrapper& data() const { return data_; };

    /// Returns a proxy to an image row.
    row_proxy operator[](size_t index) { return row_proxy(index, *this); };
    /// Returns a proxy to an image row.
    const row_proxy operator[](size_t index) const
    {
        return row_proxy(index, *this);
    };

    /// Returns true if image loaded successfully (opposite of fail()).
    operator bool() { return !fail_; }
    /// Returns true if image failed to load.
    bool fail() { return fail_; }
    /// Reason of failure. Empty if failure didn't occur.
    std::string fail_msg() const { return fail_msg_; }

    /**
     * @brief Subsample an image by bit shifting its dimensions.
     *
     * Specialized function to subsample by bit shifting the image dimensions
     * to the right by a given amount.
     *
     * @param[in] im - Image to shift
     * @param[in] shift - Number of bits to shift to right.
     * @param[in] min_width - Minimum resulting image width.
     * @param[in] min_height - Minimum resulting image height.
     *
     * @return The subsampled image.
     */
    friend image subsampled_shift(const image& im,
                                  std::uint32_t shift,
                                  size_t min_width,
                                  size_t min_height);

  private:
    image_wrapper data_;

    size_t width_;
    size_t height_;
    size_t channels_;

    bool fail_ = false;
    std::string fail_msg_;
};

/**
 * @brief Recursively find all the image files in the given directory.
 *
 * @param[in] root - Path to the directory to search.
 *
 * @return Vector of all images found.
 */
std::vector<std::filesystem::path>
get_image_paths(const std::filesystem::path& root);

}

#endif
